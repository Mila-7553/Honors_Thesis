2025-08-20
Mila, As previously, I'm making a new branch to explicitly document the comments/suggestions I have.

(1) Generalizing the structure of your functions to work on many "sets" of data: `calculate_delta_t`

Consider the code in your function `calculate_delta_t`
It currently looks like:

def calculate_delta_t(times):
    times = np.array(times)
    if type(times[0]) == list or type(times[0]) == np.ndarray:
        times0 = times[:,0]
        times1 = times[:,1]
        times2 = times[:,2]
    else:
        times0 = times[0]
        times1 = times[1]
        times2 = times[2]
    d_t1 =times0 - times1
    d_t3 = times2 - times1
    d_t = times2 - times0
    return (d_t1,d_t3,d_t)

You can simplify this by using numpy's built-in capabilities to enforce array shapes. For example:
def delta(t0,t1,t2):
    # Ensure t0, t1, and t2 are 1D numpy arrays
    t0, t1, t2 = np.atleast_1d(t0, t1, t2)
    # Check that the shapes match
    if t0.shape != t1.shape or t0.shape != t2.shape:
        raise ValueError("Input arrays must have the same shape")
    # Calculate and return the differences
    return (t0-t1, t2-t1, t2-t0)


I note:
(1) What we are really doing is generalizing the function to ALWAYS do the calculation necessary for ARRAY
inputs, even if the input is for single numbers. We just enforce the input arguments to be 1D arrays at the start.
(2) I find it clearer to pass the three arrays as separate arguments rather than a single array of arrays.
(3) you have done this kind of structure already in some of your other functions such as `calculate_a_and_b`.
So my suggestion above is just to ensure that you adopt the same approach in all of your functions.




(2) Generalizing the structure of your functions to work on many "sets" of data: `calculate_values_for_cs`

My suggestion here is basically the same as above, but I'll talk through it in more detail because
handling the 2D array structure can be a bit more complex.

I suggest you do something approximately as follows:
def calculate_values_for_cs(a_1, b_1, a_3, b_3, position_R, rho, B_matrix):
    # Ensure inputs are arrays
    a_1, b_1, a_3, b_3 = map(np.atleast_1d, (a_1, b_1, a_3, b_3))
    # Check that the shapes match
    if a_1.shape != b_1.shape or a_1.shape != a_3.shape or a_1.shape != b_3.shape:
        raise ValueError("Input arrays must have the same shape")

    # If single 3Ã—3 matrices, add a batch dimension (N=1): I.e. (3,3) -> (1,3,3)
    if rho.ndim == 2:
        rho  = rho[None, ...]
        B_matrix = B_matrix[None, ...]
        position_R = position_R[None, ...]
    # Ensure position_R, rho, and B_matrix are numpy arrays of shape (len(a_1), 3, 3)
    if rho.shape != (len(a_1), 3, 3) or B_matrix.shape != (len(a_1), 3, 3) or position_R.shape != (len(a_1), 3, 3):
        raise ValueError("rho, B_matrix, and position_R must have shape (len(a_1), 3, 3)")

    # Extract components
    rh01, rh11, rh21 = rho[:,0,1], rho[:,1,1], rho[:,2,1]
    bmatrix10, bmatrix11, bmatrix12 = B_matrix[:,1,0], B_matrix[:,1,1], B_matrix[:,1,2]
    pos_r01, pos_r11, pos_r21 = position_R[:,0,1], position_R[:,1,1], position_R[:,2,1]

    # Build helper vectors
    p2 = np.stack([rh01, rh11, rh21], axis=1)        # shape (N,3)
    R2 = np.stack([pos_r01, pos_r11, pos_r21], axis=1) # shape (N,3)

    # Core computations
    d_1 = bmatrix10 * a_1 - bmatrix11 + bmatrix12 * a_3
    d_2 = bmatrix10 * b_1 + bmatrix12 * b_3
    magnitude_R_2 = np.sqrt(np.sum(R2**2, axis=1))
    pos_2_dot_p2  = np.sum(R2 * p2, axis=1)

    return d_1, d_2, magnitude_R_2, pos_2_dot_p2

I note that in the above I have NOT checked that the code actually works!!
I have just typed it out to illustrate the structure I suggest.
You will need to test and debug it yourself.


(3) 'calculate_rhos_and_r'
 - You should be able to apply the approach from (2) to this function as well.



